#!/usr/bin/env python3
import configparser
import json
import os
import urllib.request
from typing import Any, Dict, List, Optional

import yaml

min_compat_version = "0.1.11"
python_versions = tuple(["py38", "py39", "py310", "py311"])
plugin_dirs = tuple(sorted([os.path.join("plugins", d) for d in os.listdir("plugins")]))
plugin_folders = tuple([d.replace("plugins/", "") for d in plugin_dirs])


def update_header(filename: str, header: str) -> None:
    with open(filename, "r") as f:
        content = f.readlines()
    if not content or content[0] != header:
        content.insert(0, header)
        with open(filename, "w") as f:
            f.writelines(content)


def update_mypy_ini() -> None:
    filename = "mypy.ini"
    header = ";  mypy_path generated by update_config.py using pre-commit hook\n"
    update_header(filename, header)

    with open(filename, "r") as f:
        content = f.readlines()
    dirs_with_src = [f"{plugin_dir}/src" for plugin_dir in plugin_dirs]
    dirs_with_src.insert(0, "core/src")
    new_mypy_path = f"mypy_path = {','.join(dirs_with_src)}\n"
    for idx, line in enumerate(content):
        if line.startswith("mypy_path"):
            if line != new_mypy_path:
                content[idx] = new_mypy_path
                with open("mypy.ini", "w") as f:
                    f.writelines(content)
                print("mypy.ini updated for new plugins.")
            break


def update_pytest_ini() -> None:
    filename = "pytest.ini"
    header = ";  pythonpath, testpaths generated by update_config.py using pre-commit hook\n"
    update_header(filename, header)

    with open(filename, "r") as f:
        content = f.readlines()
    updated = False
    src_dirs = [f"{plugin_dir}/src" for plugin_dir in plugin_dirs]
    src_dirs.insert(0, "core/src")
    new_pythonpath = f"pythonpath = {' '.join(src_dirs)}\n"
    test_dirs = [f"{plugin_dir}/tests" for plugin_dir in plugin_dirs]
    test_dirs.insert(0, "core/tests")
    new_testpaths = f"testpaths = {' '.join(test_dirs)}\n"
    for idx, line in enumerate(content):
        if line.startswith("pythonpath = "):
            if line != new_pythonpath:
                content[idx] = new_pythonpath
                updated = True
        elif line.startswith("testpaths = "):
            if line != new_testpaths:
                content[idx] = new_testpaths
                updated = True
    if updated:
        with open(filename, "w") as f:
            f.writelines(content)
        print("pytest.ini updated for new plugins.")


def none_representer(dumper, data):  # type: ignore
    return dumper.represent_scalar("tag:yaml.org,2002:null", "")


for resolver in list(yaml.SafeLoader.yaml_implicit_resolvers.get("o", [])):
    if resolver[0] == "tag:yaml.org,2002:bool":
        yaml.SafeLoader.yaml_implicit_resolvers["o"].remove(resolver)


class CustomDumper(yaml.SafeDumper):
    def increase_indent(self, flow=False, indentless=False):  # type: ignore
        return super(CustomDumper, self).increase_indent(flow, False)


def is_simple_string_list(lst: List[Any]) -> bool:
    return all(isinstance(item, str) and "\n" not in item for item in lst)


def represent_list(dumper, data) -> Any:  # type: ignore
    """Represents the list of strings as a single line if possible."""
    if is_simple_string_list(data) and "bodhiext" not in "".join(data):
        return dumper.represent_sequence("tag:yaml.org,2002:seq", data, flow_style=True)
    else:
        return dumper.represent_sequence("tag:yaml.org,2002:seq", data, flow_style=False)


def represent_ordered_dict(dumper, data) -> Any:  # type: ignore
    """Custom representer for dictionaries to maintain the insertion order."""
    return dumper.represent_mapping("tag:yaml.org,2002:map", data.items())


def multi_line_string_representer(dumper, data) -> Any:  # type: ignore
    """Represents multi-line strings with the '|' character."""
    if "\n" in data:
        return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="|")
    return dumper.represent_scalar("tag:yaml.org,2002:str", data)


# Add the custom representer to only the CustomSafeDumper
CustomDumper.add_representer(list, represent_list)
CustomDumper.add_representer(dict, represent_ordered_dict)
CustomDumper.add_representer(str, multi_line_string_representer)
CustomDumper.add_representer(type(None), none_representer)


def update_github_workflows() -> None:
    filename = ".github/workflows/plugins.yml"
    header = "# workflow_dispatch/plugin/options generated by update_config.py using pre-commit, yaml reformatted\n"
    update_header(filename, header)

    workflows = yaml.safe_load(open(filename, "r").read())
    current_options = sorted(workflows["on"]["workflow_dispatch"]["inputs"]["plugin"]["options"])
    dirs_with_pyproject = sorted(
        [root.replace("plugins/", "") for root, _, files in os.walk("plugins") if "pyproject.toml" in files]
    )
    dirs_with_pyproject.insert(0, "all")
    if current_options == dirs_with_pyproject:
        return
    workflows["on"]["workflow_dispatch"]["inputs"]["plugin"]["options"] = dirs_with_pyproject
    with open(filename, "w") as f:
        f.writelines([header])
        yaml.dump(workflows, f, Dumper=CustomDumper, default_flow_style=False, width=250)
    print("Updated github workflows for new plugins.")


def fetch_versions(package_name: str, min_version: str) -> List[str]:
    with urllib.request.urlopen(f"https://pypi.org/pypi/{package_name}/json") as response:
        data = response.read()
        package_info = json.loads(data)
    min_version_ints = tuple(map(int, min_version.split(".")))
    releases_with_time = {k: val[0]["upload_time"] for k, val in package_info["releases"].items()}
    valid_versions = {
        k: val for k, val in releases_with_time.items() if tuple(map(int, k.split("."))) >= min_version_ints
    }
    sorted_versions = dict(sorted(valid_versions.items(), key=lambda item: item[1], reverse=True))
    return list(sorted_versions.keys())


def fetch_gh_releases(owner: str, repo: str, token: Optional[str] = None) -> Dict[str, Any]:
    url = f"https://api.github.com/repos/{owner}/{repo}/releases"
    headers = {
        "Accept": "application/vnd.github.v3+json",
    }
    if token:
        headers["Authorization"] = f"token {token}"
    req = urllib.request.Request(url, headers=headers)
    with urllib.request.urlopen(req) as response:
        if response.status == 200:
            body = response.read()
            data = json.loads(body)
            return data  # type: ignore
        else:
            raise Exception(f"HTTP error {response.status}: {response.reason}")


def create_tox_file(filename: str, plugin_slug: str) -> None:
    with open("templates/tox.ini", "r") as f:
        content = f.read()
    py_versions = ",".join(python_versions)
    bodhilib_versions = fetch_versions("bodhilib", min_compat_version)
    bodhilib_versions = [version.replace(".", "_") for version in bodhilib_versions]
    core_versions = ",".join(bodhilib_versions)
    formatted_content = content.format(py_versions=py_versions, plugin_slug=plugin_slug, core_versions=core_versions)
    with open(filename, "w") as f:
        f.write(formatted_content)


def update_tox_ini(plugin_dir: str) -> None:
    filename = f"{plugin_dir}/tox.ini"
    plugin_slug = plugin_dir.replace("plugins/", "").replace(".", "_")
    if not os.path.exists(filename):
        create_tox_file(filename, plugin_slug)

    header = "# [tox].envlist generated by update_config.py using pre-commit, toml reformatted\n"
    update_header(filename, header)

    config = configparser.ConfigParser()
    config.read(filename)
    bodhilib_versions = fetch_versions("bodhilib", min_compat_version)
    bodhilib_versions = [version.replace(".", "_") for version in bodhilib_versions]
    bodhilib_versions.append("pre")
    py_versions = ",".join(python_versions)
    core_versions = ",".join(bodhilib_versions)
    expected_envlist = "{" + py_versions + "}-plugins_{" + plugin_slug + "}-bodhilib_{" + core_versions + "}"
    if config["tox"]["envlist"] != expected_envlist:
        config["tox"]["envlist"] = expected_envlist
        with open(filename, "w") as f:
            f.write(header)
            config.write(f)
            print("Updated tox.ini for new bodhilib versions.")


def update_tox_inis() -> None:
    for plugin_dir in plugin_dirs:
        update_tox_ini(plugin_dir)


if __name__ == "__main__":
    update_mypy_ini()
    update_pytest_ini()
    update_github_workflows()
    update_tox_inis()
