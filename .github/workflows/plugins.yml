# workflow_dispatch/plugin/options generated by update_config.py using pre-commit, yaml reformatted
name: plugins
on:
  pull_request:
  push:
    branches: [main]
    tags: [v*]
    paths: [plugins/**, .github/**]
  workflow_dispatch:
    branches: [main]
    inputs:
      release:
        description: Publish a plugin library release (yes) or pre-release (pre) or
          none (no)? (yes/pre/no)
        required: false
        default: 'no'
      plugin:
        description: Plugin to release?
        type: choice
        options:
          - all
          - bodhiext.common
        required: true
        default: all
jobs:
  prepare:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set up Python with Poetry
        uses: ./.github/actions/setup
        with:
          setup: 'true'
          install-command: "echo 'packages installed from ci/requirements.txt'"
  pre-commit:
    needs: [prepare]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set up Python with Poetry
        uses: ./.github/actions/setup
      - name: Check poetry files
        shell: bash
        run: |
          make all.check
      - name: Pre-commit
        uses: pre-commit/action@v3.0.0
  determine_plugin:
    runs-on: ubuntu-latest
    needs: [pre-commit]
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Install jq
        run: sudo apt-get install -y jq
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Determine plugin(s) based on workflow input or git diff
        id: set-matrix
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # If the workflow was triggered manually with workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.plugin }}" == "all" ]]; then
              # Get all directories inside plugins
              PLUGINS=$(ls -d plugins/* | cut -d'/' -f2 | jq -R -s -c 'split("\n")[:-1]')
            else
              # If a specific plugin is provided as input
              PLUGINS=$(echo "[\"${{ github.event.inputs.plugin }}\"]")
            fi
          else
            # Logic based on git diff for push events
            LAST_SUCCESS_COMMIT=$(curl -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/$GITHUB_REPOSITORY/actions/workflows/plugins.yml/runs?status=success&per_page=1" \
              | jq -r '.workflow_runs[0].head_sha')
            git fetch origin $LAST_SUCCESS_COMMIT
            PLUGINS=$(git diff --dirstat=files,0 $LAST_SUCCESS_COMMIT..$GITHUB_SHA \
              | grep 'plugins/' \
              | cut -d '/' -f2 \
              | uniq \
              | jq -R -s -c 'split("\n")[:-1]')
          fi
          echo "matrix=$PLUGINS" # debug
          echo "matrix=$PLUGINS" >> "$GITHUB_OUTPUT"
  run-test:
    needs: determine_plugin
    if: ${{ toJson(fromJson(needs.determine_plugin.outputs.matrix)) != '[]'}}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        plugin: ${{ fromJson(needs.determine_plugin.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set PLUGIN_DIR
        run: |
          PLUGIN_FOLDER=${{ matrix.plugin }}
          PLUGIN_DIR=plugins/${PLUGIN_FOLDER}
          echo "PLUGIN_FOLDER=${PLUGIN_FOLDER}" # debug
          echo "PLUGIN_FOLDER=${PLUGIN_FOLDER}" >> $GITHUB_ENV
          echo "PLUGIN_DIR=${PLUGIN_DIR}" # debug
          echo "PLUGIN_DIR=${PLUGIN_DIR}" >> $GITHUB_ENV
      - name: Set up Python with Poetry
        uses: ./.github/actions/setup
        with:
          setup: 'true'
          working-directory: ${{ env.PLUGIN_DIR }}
      - name: Copy .env.ci to .env.test
        run: |
          cd ${{ env.PLUGIN_DIR }}
          cp .env.ci .env.test
      - name: Run tests
        run: |
          make ci.test ${{ env.PLUGIN_FOLDER }}
      - name: Build
        run: |
          make ci.build ${{ env.PLUGIN_FOLDER }}
      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v3
        with:
          env_vars: OS,PYTHON
          files: ${{ env.PLUGIN_DIR }}/coverage.xml
          flags: unittests,${{ env.PLUGIN_FOLDER }}
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
  run-tox:
    needs: [run-test, determine_plugin]
    if: ${{ toJson(fromJson(needs.determine_plugin.outputs.matrix)) != '[]' && github.event.inputs.release != '' && (github.event.inputs.release == 'yes' || github.event.inputs.release == 'pre') }}
    strategy:
      fail-fast: false
      matrix:
        plugin: ${{ fromJson(needs.determine_plugin.outputs.matrix) }}
        os: [ubuntu-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set up Python with Poetry
        uses: ./.github/actions/setup
      - name: Run tox
        run: |
          make_opts=""
          # if inputs set as pre or no, then find the min supported version, and the latest pre-release
          if [[ "${{ github.event.inputs.release }}" == "pre" ]]; then
            make_opts="--only-min --include-prerelease"
          fi
          make ci.tox ${make_opts} ${{ matrix.plugin }}
  prerelease:
    needs: [run-tox, determine_plugin]
    if: ${{ github.event.inputs.release == 'pre' && toJson(fromJson(needs.determine_plugin.outputs.matrix)) != '[]' }}
    strategy:
      matrix:
        plugin: ${{ fromJson(needs.determine_plugin.outputs.matrix) }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
    steps:
      - name: Set PLUGIN envs
        run: |
          PLUGIN_FOLDER=${{ matrix.plugin }}
          PLUGIN_DIR=plugins/${PLUGIN_FOLDER}
          echo "PLUGIN_FOLDER=${PLUGIN_FOLDER}" # debug
          echo "PLUGIN_FOLDER=${PLUGIN_FOLDER}" >> $GITHUB_ENV
          echo "PLUGIN_DIR=${PLUGIN_DIR}" # debug
          echo "PLUGIN_DIR=${PLUGIN_DIR}" >> $GITHUB_ENV
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Find min supported bodhilib version
        id: min-supported-version
        run: |
          MIN_SUPPORTED_VERSION=$(make ci.supports -- ${{ env.PLUGIN_FOLDER }}) --only-min
          echo "version=${MIN_SUPPORTED_VERSION}" # debug
          echo "version=${MIN_SUPPORTED_VERSION}" >> $GITHUB_OUTPUT
      - name: Set up Python with Poetry
        uses: ./.github/actions/ondemand
        with:
          working-directory: ${{ env.PLUGIN_DIR }}
          bodhilib-version: ${{ steps.min-supported-version.outputs.version }}
      - name: Get current version
        id: current-version
        run: |
          CURRENT_VERSION="$(poetry version --short --directory \"${PLUGIN_DIR}\")"
          echo "CURRENT_VERSION=${CURRENT_VERSION}" # debug
          echo "CURRENT_VERSION=${CURRENT_VERSION}" >> $GITHUB_ENV
      - name: Set new pre-release version
        id: new-version
        run: |
          NEW_VERSION="${CURRENT_VERSION}-$(date +'%Y%m%d%H%M%S')"
          echo "NEW_VERSION=${NEW_VERSION}" # debug
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV
      - name: Update version to pre-release version
        run: |
          VERSION_FILE=$(find "${PLUGIN_DIR}/src/" -name "_version.py" -type f | head -n 1)
          poetry version "${NEW_VERSION}" --directory "${PLUGIN_DIR}"
          echo "__version__ = \"${NEW_VERSION}\"" > ${VERSION_FILE}
      - name: Build package
        run: make ci.build ${PLUGIN_NAME}
      - name: Create pre-release
        uses: ncipollo/release-action@v1
        with:
          artifacts: ${{ env.PLUGIN_DIR }}/dist/*
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ env.PLUGIN }}/v${{ env.NEW_VERSION }}
          name: ${{ env.PLUGIN }}/v${{ env.NEW_VERSION }}
          prerelease: true
  release:
    needs: [run-tox, determine_plugin]
    if: ${{ github.event.inputs.release == 'yes' && toJson(fromJson(needs.determine_plugin.outputs.matrix)) != '[]' }}
    strategy:
      matrix:
        plugin: ${{ fromJson(needs.determine_plugin.outputs.matrix) }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
    steps:
      - name: Set PLUGIN envs
        run: |
          PLUGIN_FOLDER=${{ matrix.plugin }}
          PLUGIN_DIR=plugins/${PLUGIN_FOLDER}
          echo "PLUGIN_FOLDER=${PLUGIN_FOLDER}" # debug
          echo "PLUGIN_FOLDER=${PLUGIN_FOLDER}" >> $GITHUB_ENV
          echo "PLUGIN_DIR=${PLUGIN_DIR}" # debug
          echo "PLUGIN_DIR=${PLUGIN_DIR}" >> $GITHUB_ENV
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Find min supported bodhilib version
        id: min-supported-version
        run: |
          MIN_SUPPORTED_VERSION=$(make ci.supports -- ${{ env.PLUGIN_FOLDER }}) --only-min
          echo "version=${MIN_SUPPORTED_VERSION}" # debug
          echo "version=${MIN_SUPPORTED_VERSION}" >> $GITHUB_OUTPUT
      - name: Set up Python with Poetry
        uses: ./.github/actions/ondemand
        with:
          working-directory: ${{ env.PLUGIN_DIR }}
          bodhilib-version: ${{ steps.min-supported-version.outputs.version }}
      - name: Get current version
        id: current-version
        run: |
          CURRENT_VERSION=$(poetry version --short --directory \"${PLUGIN_DIR}\")
          echo "CURRENT_VERSION=${CURRENT_VERSION}" # debug
          echo "CURRENT_VERSION=${CURRENT_VERSION}" >> $GITHUB_ENV
      - name: Build package
        run: make ci.build ${PLUGIN_NAME}
      - name: Create Release
        uses: ncipollo/release-action@v1
        with:
          artifacts: ${{ env.PLUGIN_DIR }}/dist/*
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ env.PLUGIN }}/v${{ env.CURRENT_VERSION }}
          name: ${{ env.PLUGIN }}/v${{ env.CURRENT_VERSION }}
          commit: main
      - name: Publish package to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          verbose: true
          print-hash: true
          packages-dir: ${{ env.PLUGIN_DIR }}/dist/
      - name: Export NEW_VERSION and VERSION_FILE
        run: |
          IFS='.' read -ra ADDR <<< "$CURRENT_VERSION"
          new_patch=$(( ${ADDR[2]} + 1 ))
          NEW_VERSION="${ADDR[0]}.${ADDR[1]}.$new_patch"
          echo "NEW_VERSION=$NEW_VERSION" # debug
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          VERSION_FILE=$(find "${PLUGIN_DIR}/src/" -name "_version.py" -type f | head -n 1)
          echo "VERSION_FILE=$VERSION_FILE" # debug
          echo "VERSION_FILE=$VERSION_FILE" >> $GITHUB_ENV
      - name: Bump patch version
        run: |
          poetry version "${NEW_VERSION}" --directory "${PLUGIN_DIR}"
          # Overwrite the _version.py file with the new version
          echo "# this file is automatically generated and overwritten by CI process" > ${VERSION_FILE}
          echo "# to modify the content, modify the CI workflow file - .github/workflows/main.yml, job: \"Bump patch version\"" >> ${VERSION_FILE}
          echo "__version__ = \"${NEW_VERSION}\"" >> ${VERSION_FILE}
      - name: Commit and push changes
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "<github-actions@users.noreply.github.com>"
          git add ${PLUGIN_DIR}/pyproject.toml
          git add ${VERSION_FILE}
          git commit -m "[Github Workflows] bumping up the ${PLUGIN_FOLDER} patch version to ${NEW_VERSION}"
          git push
